************
SO3partArr
************

Similary to the tensor array classes in ``cnine``, the basic tool for parallelizing SO3-operations in GElib 
are the ``SO3partArr`` and ``SO3vecArr`` classes. 
An ``SO3partArr`` is a multidimensional array of ``SO3part`` objects with the same :math:`\ell` and :math:`n`. 

.. code-block:: python

 >>> A=gelib.SO3partArr.gaussian([2,2],2,2) # Create a 2x2 array of SO3parts with l=2 and n=2
 >>> print(A)
 Cell (0,0)
 [ (-1.23974,-0.653697) (-0.407472,-0.645572) ]
 [ (1.61201,0.471302) (0.399771,1.52415) ]
 [ (1.3828,0.321597) (0.0523187,-0.406172) ]
 [ (-0.904146,-1.41157) (1.87065,-1.49311) ]
 [ (-1.66043,-1.36411) (-0.688081,1.01046) ]


 Cell (0,1)
 [ (-1.50279,0.0436305) (0.570759,-1.11315) ]
 [ (-0.929941,-0.410768) (-0.934988,-1.3031) ]
 [ (-0.764676,-0.807584) (0.250854,1.31755) ]
 [ (-0.188164,1.29412) (-1.51315,-1.48009) ]
 [ (1.32256,-0.795502) (1.93468,0.333338) ]


 Cell (1,0)
 [ (-1.13769,0.682072) (-1.22027,-0.711608) ]
 [ (0.111152,0.177093) (-0.672931,-0.787544) ]
 [ (-1.39814,-0.822316) (-0.477463,-0.517104) ]
 [ (0.643125,0.328867) (1.37519,0.321593) ]
 [ (-1.2589,-1.05669) (0.259477,0.525259) ]


 Cell (1,1)
 [ (-1.20183,0.967431) (-0.399454,-0.438438) ]
 [ (-0.727057,1.89024) (0.43853,-0.750291) ]
 [ (-0.42954,-0.566975) (-2.20967,1.39586) ]
 [ (-1.22569,0.0196838) (0.73464,0.550065) ]
 [ (0.630166,-1.0417) (0.137796,-0.579859) ]

.. code-block:: python

 >>> print(adims)
 (2,2)
 >>> print(A.getl())
 2
 >>> print(A.getn())
 2

==============================
Access and arithmetic
==============================

Individual cells are accessed similarly to how cells are accessed in ``cnine``.

.. code-block:: python

 >>> a=A([0,1])
 >>> print(a)
 Cell (0)
 [ (-1.50279,0.0436305) (0.570759,-1.11315) ]
 [ (-0.929941,-0.410768) (-0.934988,-1.3031) ]
 [ (-0.764676,-0.807584) (0.250854,1.31755) ]
 [ (-0.188164,1.29412) (-1.51315,-1.48009) ]
 [ (1.32256,-0.795502) (1.93468,0.333338) ]


.. code-block:: python

 >>> A[[0,1]]=gelib.SO3part.ones(2,2)
 >>> print(A)
 Cell (0,0)
 [ (-1.23974,-0.653697) (-0.407472,-0.645572) ]
 [ (1.61201,0.471302) (0.399771,1.52415) ]
 [ (1.3828,0.321597) (0.0523187,-0.406172) ]
 [ (-0.904146,-1.41157) (1.87065,-1.49311) ]
 [ (-1.66043,-1.36411) (-0.688081,1.01046) ]
 
 Cell (0,1)
 [ (1,0) (1,0) ]
 [ (1,0) (1,0) ]
 [ (1,0) (1,0) ]
 [ (1,0) (1,0) ]
 [ (1,0) (1,0) ]


 Cell (1,0)
 [ (-1.13769,0.682072) (-1.22027,-0.711608) ]
 [ (0.111152,0.177093) (-0.672931,-0.787544) ]
 [ (-1.39814,-0.822316) (-0.477463,-0.517104) ]
 [ (0.643125,0.328867) (1.37519,0.321593) ]
 [ (-1.2589,-1.05669) (0.259477,0.525259) ]


 Cell (1,1)
 [ (-1.20183,0.967431) (-0.399454,-0.438438) ]
 [ (-0.727057,1.89024) (0.43853,-0.750291) ]
 [ (-0.42954,-0.566975) (-2.20967,1.39586) ]
 [ (-1.22569,0.0196838) (0.73464,0.550065) ]
 [ (0.630166,-1.0417) (0.137796,-0.579859) ]


``SO3partArr`` supports the same arithmetic operations as ``SO3part``. 

.. code-block:: python

 >>> A=gelib.SO3partArr.gaussian([2,2],2,2)
 >>> B=gelib.SO3partArr.gaussian([2,2],2,2)
 >>> C=A+3.0*B
 >>> print(C)
 Cell (0,0)
 [ (-1.40824,0.173633) (2.01319,2.06771) ]
 [ (0.95446,0.362785) (3.09968,-0.604) ]
 [ (3.90968,-1.27518) (-4.6316,-1.91285) ]
 [ (-2.91648,1.11861) (6.75739,-3.3433) ]
 [ (5.60193,2.02917) (-2.05515,3.39223) ]


 Cell (0,1)
 [ (-0.878683,1.79587) (-4.11548,1.69023) ]
 [ (-2.67181,-2.16335) (-6.12109,-2.53548) ]
 [ (1.07321,-4.90121) (0.801977,1.07128) ]
 [ (0.580513,-2.46728) (4.11372,1.31351) ]
 [ (1.28874,1.5389) (4.43955,-0.593475) ]


 Cell (1,0)
 [ (1.74549,-2.44168) (1.05751,-2.45381) ]
 [ (-0.320786,2.51112) (-5.84286,1.53829) ]
 [ (-5.45803,2.86869) (1.82332,-1.27612) ]
 [ (2.77492,-1.11461) (1.57132,0.535154) ]
 [ (3.48679,-5.35123) (-3.51263,-5.71158) ]


 Cell (1,1)
 [ (-3.64723,1.52523) (1.99561,4.51333) ]
 [ (4.58464,3.7242) (3.60309,-5.42) ]
 [ (-5.5616,0.933842) (-3.59003,5.55532) ]
 [ (0.309147,-4.48022) (1.86785,-0.0473309) ]
 [ (0.405166,-0.958648) (-0.295878,1.07429) ]


=======================
Clebsch-Gordan products
=======================

The cellwise Clebsch--Gordan product of two ``SO3partArr`` objects is computed the natural way. 


.. code-block:: python

 >>> C=gelib.CGproduct(A,B,2)
 >>> print(C)
 Cell (0,0)
 [ (-0.612916,0.358383) (0.131453,2.15649) (-0.287549,0.0733472) (-0.55767,-0.214064) ]
 [ (0.841384,-0.353344) (-1.01196,-0.879668) (0.436334,0.141616) (1.20368,0.592236) ]
 [ (-2.02799,-1.18029) (1.88476,-1.34696) (-0.71247,-1.12946) (0.332777,-0.353586) ]
 [ (3.13636,2.11072) (-3.18043,0.0421931) (-0.663264,3.10037) (0.177597,0.481469) ]
 [ (-0.717206,0.989761) (2.08029,3.23287) (0.288023,-1.53175) (-0.386861,1.81005) ]


 Cell (0,1)
 [ (-0.489566,0.270065) (-0.0457406,-0.352368) (-0.865488,-1.40888) (-1.56804,-2.83532) ]
 [ (-0.42723,0.82852) (-2.68106,-2.75835) (0.00345355,-1.31936) (3.87798,0.248769) ]
 [ (1.2557,-0.482106) (-1.39484,0.623614) (-0.969488,1.32671) (-1.40121,-0.0573585) ]
 [ (-0.709001,-1.15556) (-2.13888,1.03561) (0.391652,-1.64895) (-2.56553,-2.10414) ]
 [ (-0.837281,-1.90985) (0.640284,-1.84462) (1.79583,-2.19929) (1.48982,3.23427) ]


 Cell (1,0)
 [ (-0.700825,-0.925768) (-0.981545,0.677117) (0.353064,-0.0191347) (-2.10966,-0.735287) ]
 [ (0.188051,0.730757) (-0.48487,-0.22269) (-0.335629,-0.665925) (0.650875,-0.473607) ]
 [ (-3.27631,2.07015) (1.00224,0.902784) (-2.18499,0.607909) (-0.133402,2.22459) ]
 [ (1.64995,-0.578507) (1.96081,0.273189) (-0.966605,-0.401362) (-1.38236,1.14842) ]
 [ (-0.608622,0.36057) (-0.645293,1.79936) (-2.07356,0.00236022) (-0.120193,0.980501) ]


 Cell (1,1)
 [ (2.68297,-2.90167) (-1.52855,-3.79575) (0.497969,0.160464) (-1.28959,-0.577087) ]
 [ (1.23007,2.64437) (0.135042,-0.43523) (0.350563,-0.65988) (-0.548198,-0.542562) ]
 [ (-0.606422,0.415338) (0.159727,0.606347) (-1.61022,2.2472) (1.66179,1.52155) ]
 [ (0.877033,-0.98302) (-1.30973,-1.31185) (0.53583,-1.4956) (0.176557,-0.774645) ]
 [ (0.11913,-0.072755) (1.11784,0.475784) (-0.689207,1.01557) (-0.0981837,-0.554621) ]


==============
GPU operations
==============

``SO3partArr`` objects can be moved to/from the GPU the same way as ``SO3part`` and ``SO3vec`` objects. 

The benefits of GPU acceleration for arrayed objects is particularly great, because the corresponding 
kernels (specifically, kernels implementing Clebsch-Gordan operations) are written in a way as to 
parallelize the operation across array cells.  