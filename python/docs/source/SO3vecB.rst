******
SO3vec
******


An ``SO3vec`` object represents a general SO(3)-covariant vector, stored 
as a sequence of ``SO3part`` objects. 
Similarly to ``SO3part``, ``SO3vec`` also has a batch dimension. 

The `type` of an ``SO3vec`` is a list specifying the multiplicity of each of its parts. 
For example, the following creates a random ``SO3vec`` of type (2,3,1). 

.. code-block:: python

  >>> v=gelib.SO3vec.randn(1,[2,3,1])
  >>> v
  <gelib_torchC.SO3vec object at 0x7f974337bb70>
  >>> print(v)
  Part l=0:
    [ (0.289356,1.54426) (-1.34567,1.53707) ]


  Part l=1:
    [ (-1.01328,-0.592903) (-1.11794,0.749696) (-0.734772,1.43901) ]
    [ (0.541032,1.58891) (-1.55468,-0.30842) (-0.937764,0.634763) ]
    [ (0.871103,-0.726917) (0.787215,-1.39109) (2.66829,0.85663) ]


  Part l=2:
    [ (-0.440433,-0.919034) (-0.700111,-0.901544) (1.29377,-0.482789) (-1.26476,-1.61195) (-1.42624,-0.967444) ]


The batch dimension and type of an SO(3)-vector can be accessed as follows.

.. code-block:: python

 >>> v.getb()
 1
 >>> v.tau()
 [2, 3, 1]

The invidual parts are stored in the ``parts`` member variable

.. code-block:: python

  >>> print(v.parts[1])
    [ (-1.01328,-0.592903) (-1.11794,0.749696) (-0.734772,1.43901) ]
    [ (0.541032,1.58891) (-1.55468,-0.30842) (-0.937764,0.634763) ]
    [ (0.871103,-0.726917) (0.787215,-1.39109) (2.66829,0.85663) ]

|

=======================
Clebsch-Gordan products
=======================

The full Clebsch-Gordan product (CG-product) of two SO3-vectors is computed as follows.

.. code-block:: python

  >>> v=gelib.SO3vec.randn(1,[2,2])
  >>> u=gelib.SO3vec.randn(1,[2,2])
  >>> v=gelib.SO3vec.randn(1,[2,2])
  >>> w=gelib.CGproduct(u,v)
  >>> print(w)
  Part l=0:
    [ (0.152031,-0.140948) (-0.176707,0.0986708) (-0.0514539,2.16813) (0.54849,-2.04492) (-1.24255,-0.815015) (-1.40811,-0.123935) (-0.391867,1.13209) (-0.161307,-0.330928) ]


  Part l=1:
    [ (0.0961476,-0.243252) (0.171405,-0.405961) (1.1234,2.495) (1.79502,4.24597) (-0.730597,0.187905) (0.736381,-0.00987765) (0.698929,0.568218) (-0.532079,-0.700114) (-0.163401,0.429268) (-0.412671,1.27816) (0.850947,-1.12338) (2.10184,-2.1415) ]
    [ (-0.0326659,-0.024234) (0.00847598,0.172192) (0.419973,-0.0682939) (-1.35334,-1.19208) (-0.374269,0.472096) (0.463849,-0.361595) (1.51776,-0.805567) (-1.62546,0.414405) (-0.0409343,-0.262541) (-0.664351,-1.61683) (-0.958011,-0.645344) (-2.28508,0.289834) ]
    [ (0.304888,-0.0110071) (0.0900037,-0.295688) (-2.14074,2.36709) (1.5615,2.83128) (-0.456644,-0.978039) (0.207788,1.03305) (-0.936221,-0.103796) (0.864218,0.314231) (0.494024,-0.0305465) (0.703364,-0.464528) (-1.7338,-0.26607) (-0.553973,1.15706) ]


  Part l=2:
    [ (-0.728853,0.612083) (-1.2514,1.00255) (1.10502,0.265513) (1.85081,0.490198) ]
    [ (-0.0748801,0.618935) (-0.0294498,0.478025) (0.970257,-1.34299) (1.06154,-1.94166) ]
    [ (-0.750575,-0.508764) (-1.11883,-0.688738) (-0.534416,0.477625) (-0.479641,1.47743) ]
    [ (-0.737463,0.204984) (0.522857,0.792809) (1.75326,0.526698) (1.35542,-1.92182) ]
    [ (0.430848,-1.52889) (-1.32246,-0.916922) (-0.943746,-1.01531) (-1.28382,0.569196) ]

The optional third argument of ``CGproduct`` can be used to limit the result to parts 
:math:`\ell=0,1,\ldots,\ell_{\text{max}}`. 

.. code-block:: python

  >>> w=gelib.CGproduct(u,v,1)
  >>> print(w)
  Part l=0:
    [ (0.152031,-0.140948) (-0.176707,0.0986708) (-0.0514539,2.16813) (0.54849,-2.04492) (-1.24255,-0.815015) (-1.40811,-0.123935) (-0.391867,1.13209) (-0.161307,-0.330928) ]


  Part l=1:
    [ (0.0961476,-0.243252) (0.171405,-0.405961) (1.1234,2.495) (1.79502,4.24597) (-0.730597,0.187905) (0.736381,-0.00987765) (0.698929,0.568218) (-0.532079,-0.700114) (-0.163401,0.429268) (-0.412671,1.27816) (0.850947,-1.12338) (2.10184,-2.1415) ]
    [ (-0.0326659,-0.024234) (0.00847598,0.172192) (0.419973,-0.0682939) (-1.35334,-1.19208) (-0.374269,0.472096) (0.463849,-0.361595) (1.51776,-0.805567) (-1.62546,0.414405) (-0.0409343,-0.262541) (-0.664351,-1.61683) (-0.958011,-0.645344) (-2.28508,0.289834) ]
    [ (0.304888,-0.0110071) (0.0900037,-0.295688) (-2.14074,2.36709) (1.5615,2.83128) (-0.456644,-0.978039) (0.207788,1.03305) (-0.936221,-0.103796) (0.864218,0.314231) (0.494024,-0.0305465) (0.703364,-0.464528) (-1.7338,-0.26607) (-0.553973,1.15706) ]

|

================================
Diagonal Clebsch-Gordan products
================================

In the full CG-product, every fragment of ``u`` is multiplied with every fragment of ``v``, 
often leading to output vectors with very large numbers of fragments. In 
contrast, the ``DiagCGproduct`` function only computes the product between corresponding fragments. 
Naturally, this means that ``u`` and ``v`` must have the same type.

.. code-block:: python

  >>> w=gelib.DiagCGproduct(u,v)
  >>> print(w)
  Part l=0:
    [ (0.152031,-0.140948) (0.54849,-2.04492) (-1.24255,-0.815015) (-0.161307,-0.330928) ]


  Part l=1:
    [ (0.0961476,-0.243252) (1.79502,4.24597) (-0.730597,0.187905) (-0.532079,-0.700114) (-0.163401,0.429268) (2.10184,-2.1415) ]
    [ (-0.0326659,-0.024234) (-1.35334,-1.19208) (-0.374269,0.472096) (-1.62546,0.414405) (-0.0409343,-0.262541) (-2.28508,0.289834) ]
    [ (0.304888,-0.0110071) (1.5615,2.83128) (-0.456644,-0.978039) (0.864218,0.314231) (0.494024,-0.0305465) (-0.553973,1.15706) ]


  Part l=2:
    [ (-0.728853,0.612083) (1.85081,0.490198) ]
    [ (-0.0748801,0.618935) (1.06154,-1.94166) ]
    [ (-0.750575,-0.508764) (-0.479641,1.47743) ]
    [ (-0.737463,0.204984) (1.35542,-1.92182) ]
    [ (0.430848,-1.52889) (-1.28382,0.569196) ]

|


==============
GPU operations
==============


``SO3vec`` objects can be can moved back and forth between the host (CPU) and the GPU 
the same way as ``SO3part`` objects. 

.. code-block:: python

  >>> A=gelib.SO3vec.randn(1,[2,3,1])
  >>> B=A.to(device='cuda') # Create a copy of A on the first GPU (GPU0)
  >>> C=B.to(device='cpu') # Move B back to the host 

Similarly to the ``SO3part`` case, operations between GPU-resident ``SO3vec`` s are executed  
on the GPU and the result is placed on the same device.  

|

